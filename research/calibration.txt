
from:
https://stackoverflow.com/questions/43364006/android-accelerometer-calibration/69408830#69408830

Answer 1

You should calibrate gains, offsets, and angle of the 3 accelerometers.

Unfortunately it's not possible to deepen the whole topic here.
I'll write a small introduction, describing the basic concept, and then I'll post a link to the code of a simple Clinometer that implements the calibration.

The calibration routine could be done with 7 misurations (calculate the mean value of a good number of samples) in different ortogonal positions at your choice, in order to have all +-0 and +-g values of your accelerometers. For example:

    STEP 1 = Lay flat
    STEP 2 = Rotate 180°
    STEP 3 = Lay on the left side
    STEP 4 = Rotate 180°
    STEP 5 = Lay vertical
    STEP 6 = Rotate 180° upside-down
    STEP 7 = Lay face down

Then you can use the 7 measurements mean[][] to calculate offsets and gains:

calibrationOffset[0] = (mean[0][2] + mean[0][3]) / 2;
calibrationOffset[1] = (mean[1][4] + mean[1][5]) / 2;
calibrationOffset[2] = (mean[2][0] + mean[2][6]) / 2;

calibrationGain[0] = (mean[0][2] - mean[0][3]) / (STANDARD_GRAVITY * 2);
calibrationGain[1] = (mean[1][4] - mean[1][5]) / (STANDARD_GRAVITY * 2);
calibrationGain[2] = (mean[2][0] - mean[2][6]) / (STANDARD_GRAVITY * 2);

using the values of mean[axis][step], where STANDARD_GRAVITY = 9.81. Then apply the Gain and Offset Corrections to measurements:

for (int i = 0; i < 7; i++) {
    mean[0][i] = (mean[0][i] - calibrationOffset[0]) / calibrationGain[0];
    mean[1][i] = (mean[1][i] - calibrationOffset[1]) / calibrationGain[1];
    mean[2][i] = (mean[2][i] - calibrationOffset[2]) / calibrationGain[2];
}

and finally calculates the correction angles:

for (int i = 0; i < 7; i++) {
    angle[0][i] = (float) (Math.toDegrees(Math.asin(mean[0][i]
        / Math.sqrt(mean[0][i] * mean[0][i] + mean[1][i] * mean[1][i] + mean[2][i] * mean[2][i]))));
    angle[1][i] = (float) (Math.toDegrees(Math.asin(mean[1][i]
        / Math.sqrt(mean[0][i] * mean[0][i] + mean[1][i] * mean[1][i] + mean[2][i] * mean[2][i]))));
    angle[2][i] = (float) (Math.toDegrees(Math.asin(mean[2][i]
        / Math.sqrt(mean[0][i] * mean[0][i] + mean[1][i] * mean[1][i] + mean[2][i] * mean[2][i]))));
}

calibrationAngle[2] =  (angle[0][0] + angle[0][1])/2;       // angle 0 = X axis
calibrationAngle[1] = -(angle[1][0] + angle[1][1])/2;       // angle 1 = Y axis
calibrationAngle[0] = -(angle[1][3] - angle[1][2])/2;       // angle 2 = Z axis

You can find a simple but complete implementation of a 3-axis calibration in this opensource Clinometer app: https://github.com/BasicAirData/Clinometer.
There is also the APK and the link of the Google Play Store if you want to try it.

    You can find the calibration routine in CalibrationActivity.java;
    The calibration parameters are applied in ClinometerActivity.java.

Furthermore, you can find a very good technical article that deepens the 3-axis calibration here: https://www.digikey.it/it/articles/using-an-accelerometer-for-inclination-sensing.
